# 流动性池与质押挖矿模块 - 整体设计文档

## 1. 项目概述

### 1.1 项目背景
基于 Solana 区块链实现一个简化的 DeFi 流动性挖矿模块，用于吸引桥接资产参与流动性提供，并通过质押机制激励长期持有者。

### 1.2 核心目标
- 提供流动性池功能，用户可存入 wrappedUSDC 获得 LP Token
- 实现质押挖矿机制，用户质押 LP Token 获得 SOL 奖励
- 支持灵活的奖励分配策略（固定速率 / 按块动态排放）
- 完整的数据记录和查询能力（基于 ClickHouse）

### 1.3 技术栈
- **区块链**: Solana（使用 solana-test-validator 进行本地测试）
- **智能合约**: Anchor Framework
- **数据库**: ClickHouse
- **开发语言**: Rust（智能合约）、TypeScript/JavaScript（客户端）
- **测试工具**: solana-test-validator、Anchor Test Framework

---

## 2. 系统架构

### 2.1 整体架构图

```
┌─────────────────────────────────────────────────────────────┐
│                        用户层                                 │
│  (Web3 钱包 - Phantom/Solflare)                             │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                    应用层 (Client)                           │
│  - TypeScript SDK                                           │
│  - 交易构建与签名                                             │
│  - 事件监听与解析                                             │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                 Solana 区块链层                              │
│                                                             │
│  ┌─────────────────────────────────────────────────┐       │
│  │    Liquidity & Staking Program (Anchor)        │       │
│  │                                                 │       │
│  │  ├─ Liquidity Pool Management                  │       │
│  │  │  - deposit()                                │       │
│  │  │  - withdraw()                               │       │
│  │  │                                             │       │
│  │  ├─ Staking Management                         │       │
│  │  │  - stake()                                  │       │
│  │  │  - unstake()                                │       │
│  │  │  - claim()                                  │       │
│  │  │                                             │       │
│  │  ├─ Reward Distribution                        │       │
│  │  │  - Fixed Rate Emission                      │       │
│  │  │  - Block-based Emission                     │       │
│  │  │                                             │       │
│  │  └─ State Management                           │       │
│  │     - Pool State                               │       │
│  │     - User Position                            │       │
│  │     - Reward Config                            │       │
│  └─────────────────────────────────────────────────┘       │
│                                                             │
│  ┌─────────────────────────────────────────────────┐       │
│  │          Token Accounts (SPL Token)             │       │
│  │  - wrappedUSDC Token                            │       │
│  │  - LP Token                                     │       │
│  │  - SOL (Native Token for Rewards)               │       │
│  └─────────────────────────────────────────────────┘       │
└───────────────────────┬─────────────────────────────────────┘
                        │
┌───────────────────────▼─────────────────────────────────────┐
│                  数据层 (ClickHouse)                         │
│                                                             │
│  ┌──────────────────────┐  ┌──────────────────────┐        │
│  │   lp_positions       │  │   reward_history     │        │
│  │  (用户持仓表)         │  │   (奖励发放历史)      │        │
│  └──────────────────────┘  └──────────────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 模块划分

#### 2.2.1 智能合约模块 (Solana Program)
- **流动性池管理**: 处理 wrappedUSDC 存取，铸造/销毁 LP Token
- **质押管理**: 处理 LP Token 质押和赎回
- **奖励计算与分配**: 实现两种奖励机制
- **状态存储**: 管理池状态、用户仓位等核心数据

#### 2.2.2 客户端 SDK 模块
- **交易构建**: 封装智能合约调用
- **事件监听**: 监听链上事件并写入 ClickHouse
- **数据查询**: 提供用户持仓和奖励历史查询接口

#### 2.2.3 数据存储模块 (ClickHouse)
- **数据采集**: 从区块链事件中提取数据
- **数据存储**: 持久化用户持仓和奖励记录
- **数据查询**: 提供高性能的历史数据查询

---

## 3. 核心功能设计

### 设计理念

本模块采用 **DeFi 行业标准的两层分离设计**：

**第一层：流动性提供层**
- 用户存入 wrappedUSDC，获得 LP Token（代表流动性份额）
- LP Token 本身是标准 SPL Token，可自由转让、交易
- 用户可随时赎回 LP Token，提取本金

**第二层：质押激励层**
- 用户可选择将 LP Token 质押，参与挖矿赚取额外奖励
- 质押是可选操作，提供灵活性
- 支持随时解除质押、领取奖励

**设计优势**：
- ✅ **灵活性**：用户可选择仅提供流动性或同时参与挖矿
- ✅ **可组合性**：LP Token 可用于其他 DeFi 协议（借贷、聚合器等）
- ✅ **标准化**：遵循 Uniswap V2、SushiSwap、Raydium 等主流协议的设计模式
- ✅ **多重激励**：可设置多个质押池，提供不同的奖励策略

### 3.1 流动性池功能

#### 3.1.1 存入流动性 (deposit)
**功能描述**: 用户存入 wrappedUSDC，获得对应数量的 LP Token

**流程**:
1. 用户授权转账 wrappedUSDC
2. 程序将 wrappedUSDC 转入池账户
3. 计算 LP Token 数量（首次存入按 1:1，后续按比例）
4. 铸造 LP Token 到用户账户
5. 更新池状态和用户持仓
6. 发出 DepositEvent 事件

**计算公式**:
```
首次存入（池子为空时）:
  lp_amount = deposit_amount

后续存入:
  lp_amount = (deposit_amount × total_lp_supply) / total_pool_balance
```

**变量说明**:
- `deposit_amount`: 用户存入的 wrappedUSDC 数量
- `lp_amount`: 用户获得的 LP Token 数量
- `total_pool_balance`: 池子当前持有的 wrappedUSDC 总量
- `total_lp_supply`: LP Token 的总供应量

**示例**:
```
场景1 - 首次存入:
  Alice 存入 1000 USDC
  → 获得 1000 LP Token
  池子状态: 1000 USDC, 1000 LP Token

场景2 - 后续存入:
  当前池子: 1000 USDC, 1000 LP Token
  Bob 存入 500 USDC
  → lp_amount = (500 × 1000) / 1000 = 500 LP Token
  池子状态: 1500 USDC, 1500 LP Token
```

#### 3.1.2 提取流动性 (withdraw)
**功能描述**: 用户销毁 LP Token，赎回对应数量的 wrappedUSDC

**流程**:
1. 检查用户 LP Token 余额
2. 计算可赎回的 wrappedUSDC 数量
3. 销毁用户的 LP Token
4. 将 wrappedUSDC 转回用户账户
5. 更新池状态和用户持仓
6. 发出 WithdrawEvent 事件

**计算公式**:
```
withdraw_amount = (lp_amount × total_pool_balance) / total_lp_supply
```

**变量说明**:
- `withdraw_amount`: 用户赎回的 wrappedUSDC 数量
- `lp_amount`: 用户销毁的 LP Token 数量
- `total_pool_balance`: 池子当前持有的 wrappedUSDC 总量
- `total_lp_supply`: LP Token 的总供应量

**示例**:
```
当前池子: 1500 USDC, 1500 LP Token
Alice 赎回 500 LP Token
→ withdraw_amount = (500 × 1500) / 1500 = 500 USDC
池子状态: 1000 USDC, 1000 LP Token
```

**重要说明**：
- LP Token 代表的是池子的**份额**，而不是固定数量的 USDC
- 如果池子产生收益（如交易手续费），早期提供者会获得更多价值
- 份额制确保公平分配池子收益

### 3.2 质押挖矿功能

**设计说明**：质押是在流动性提供之上的**可选激励层**。用户可以：
- 仅提供流动性（持有 LP Token）
- 质押 LP Token 赚取额外奖励
- 随时解除质押，灵活管理资产

#### 3.2.1 质押 LP Token (stake)
**功能描述**: 用户将 LP Token 质押到合约中开始赚取奖励

**流程**:
1. 检查用户 LP Token 余额
2. 将 LP Token 转入质押账户
3. 创建或更新用户质押仓位
4. 记录质押时间和奖励计算起点
5. 发出 StakeEvent 事件

**状态更新**:
- `user_position.staked_amount` += stake_amount
- `pool_state.total_staked` += stake_amount
- `user_position.last_stake_time` = current_timestamp

#### 3.2.2 解除质押 (unstake)
**功能描述**: 用户解除质押，取回 LP Token（不自动领取奖励）

**流程**:
1. 计算并更新待领取奖励
2. 将 LP Token 转回用户账户
3. 更新质押仓位状态
4. 发出 UnstakeEvent 事件

**状态更新**:
- 计算 `pending_reward` 并累加到 `user_position.pending_reward`
- `user_position.staked_amount` -= unstake_amount
- `pool_state.total_staked` -= unstake_amount

**重要说明**：
- 解除质押后，奖励仍保留在 `pending_reward` 中
- 用户需调用 `claim()` 才能领取奖励
- 取回的 LP Token 可以重新质押或赎回 USDC

#### 3.2.3 领取奖励 (claim)
**功能描述**: 用户领取已累计的奖励 Token (SOL)

**流程**:
1. 计算用户待领取奖励数量
2. 从奖励池转账 SOL 到用户账户
3. 更新用户奖励记录
4. 更新奖励池余额
5. 发出 ClaimEvent 事件

**状态更新**:
- 计算最新的 `pending_reward`
- 转账 `pending_reward` 数量的 SOL 给用户
- `user_position.pending_reward` = 0
- `user_position.last_claim_time` = current_timestamp

**重要说明**：
- 领取奖励**不会**解除质押，用户继续赚取奖励
- 支持随时领取，无锁定期限制
- 奖励计算使用 `reward_debt` 机制避免重复计算（Masterchef 算法）

### 3.3 奖励分配机制

#### 3.3.1 固定速率排放 (Constant Emission Rate)
**描述**: 每秒固定产出一定数量的奖励 Token

**参数**:
- `emission_rate`: 每秒排放的 Token 数量（如 10 SOL/秒）
- `total_staked`: 总质押的 LP Token 数量

**计算公式**:
```
user_reward = (user_staked_amount / total_staked) × emission_rate × time_elapsed
```

**变量说明**:
- `user_reward`: 用户应得的奖励数量
- `user_staked_amount`: 用户质押的 LP Token 数量
- `time_elapsed`: 距离上次结算的时间（秒）

**示例**:
```
配置: emission_rate = 10 SOL/秒
当前质押: total_staked = 1000 LP Token
  - Alice 质押 500 LP (占比 50%)
  - Bob 质押 500 LP (占比 50%)

经过 100 秒后:
  总奖励 = 10 × 100 = 1000 SOL
  Alice 奖励 = (500/1000) × 10 × 100 = 500 SOL
  Bob 奖励 = (500/1000) × 10 × 100 = 500 SOL
```

**特点**:
- 简单易理解
- 可预测性强
- 适合长期稳定的激励
- 奖励分配完全按质押比例

#### 3.3.2 按块动态排放 (Block-based Emission)
**描述**: 根据区块高度动态调整奖励排放量，支持衰减机制

**参数**:
- `initial_rate`: 初始每块排放量（如 100 SOL/块）
- `decay_factor`: 衰减因子（如 0.99，每周期衰减 1%）
- `blocks_per_period`: 每个周期的区块数（如 1000 块）

**计算公式**:
```
周期编号计算:
  period = current_block / blocks_per_period

当前排放率:
  current_rate = initial_rate × (decay_factor ^ period)

用户奖励:
  user_reward = (user_staked_amount / total_staked) × current_rate × blocks_elapsed
```

**变量说明**:
- `current_block`: 当前区块高度
- `period`: 当前所在周期（从 0 开始）
- `blocks_elapsed`: 距离上次结算的区块数

**示例**:
```
配置:
  initial_rate = 100 SOL/块
  decay_factor = 0.99
  blocks_per_period = 1000

周期 0 (区块 0-999):
  current_rate = 100 × (0.99^0) = 100 SOL/块

周期 1 (区块 1000-1999):
  current_rate = 100 × (0.99^1) = 99 SOL/块

周期 2 (区块 2000-2999):
  current_rate = 100 × (0.99^2) = 98.01 SOL/块

用户奖励示例（Alice 从区块 500 质押到 1500）:
  质押: 1000 LP (总质押 2000 LP，占比 50%)
  
  阶段1 (区块 500-999): 500 块 × 100 SOL/块 × 50% = 25,000 SOL
  阶段2 (区块 1000-1500): 501 块 × 99 SOL/块 × 50% = 24,799.5 SOL
  
  总奖励: 49,799.5 SOL
```

**特点**:
- 更灵活的激励策略
- 可实现通胀递减（类似比特币减半）
- 适合项目早期启动，初期高奖励吸引用户
- 长期可持续，避免奖励枯竭

---

## 4. 数据模型设计

### 4.1 链上状态账户

#### 4.1.1 Pool State (池状态)
```rust
pub struct PoolState {
    pub authority: Pubkey,              // 管理员权限
    pub wrapped_usdc_mint: Pubkey,      // wrappedUSDC Token Mint
    pub lp_token_mint: Pubkey,          // LP Token Mint
    pub pool_usdc_account: Pubkey,      // 池子持有的 USDC 账户
    pub total_deposited: u64,           // 总存入量
    pub total_lp_supply: u64,           // LP Token 总供应量
    pub total_staked: u64,              // 总质押的 LP Token 数量
    pub reward_vault: Pubkey,           // 奖励金库账户
    pub bump: u8,                       // PDA bump
}
```

#### 4.1.2 User Position (用户仓位)
```rust
pub struct UserPosition {
    pub owner: Pubkey,                  // 用户地址
    pub pool: Pubkey,                   // 关联的池子
    pub lp_balance: u64,                // 持有的 LP Token 数量
    pub staked_amount: u64,             // 质押的 LP Token 数量
    pub reward_debt: u64,               // 奖励债务（用于计算）
    pub pending_reward: u64,            // 待领取奖励
    pub last_stake_time: i64,           // 上次质押时间
    pub last_claim_time: i64,           // 上次领取时间
    pub bump: u8,                       // PDA bump
}
```

#### 4.1.3 Reward Config (奖励配置)
```rust
pub struct RewardConfig {
    pub pool: Pubkey,                   // 关联的池子
    pub emission_type: EmissionType,    // 排放类型
    pub emission_rate: u64,             // 固定排放速率（每秒）
    pub initial_block_rate: u64,        // 初始每块排放量
    pub decay_factor: u64,              // 衰减因子 (basis points, 10000 = 1.0)
    pub blocks_per_period: u64,         // 每个周期的区块数
    pub last_update_slot: u64,          // 上次更新的 slot
    pub acc_reward_per_share: u128,     // 累计每份奖励（精度放大）
    pub bump: u8,
}

pub enum EmissionType {
    FixedRate,      // 固定速率
    BlockBased,     // 按块排放
}
```

### 4.2 ClickHouse 表结构

#### 4.2.1 lp_positions (用户持仓表)
```sql
CREATE TABLE lp_positions (
    user_address String,                -- 用户钱包地址
    pool_address String,                -- 池子地址
    lp_balance UInt64,                  -- LP Token 余额
    staked_amount UInt64,               -- 质押数量
    pending_reward UInt64,              -- 待领取奖励
    total_claimed UInt64,               -- 累计已领取奖励
    last_stake_time DateTime64(3),     -- 上次质押时间
    last_claim_time DateTime64(3),     -- 上次领取时间
    last_update_time DateTime64(3),    -- 最后更新时间
    block_height UInt64,                -- 记录时的区块高度
    signature String                    -- 交易签名
) ENGINE = ReplacingMergeTree(last_update_time)
PARTITION BY toYYYYMM(last_update_time)
ORDER BY (user_address, pool_address, last_update_time);
```

#### 4.2.2 reward_history (奖励发放历史表)
```sql
CREATE TABLE reward_history (
    event_id String,                    -- 事件唯一ID
    user_address String,                -- 用户地址
    pool_address String,                -- 池子地址
    event_type Enum8(                   -- 事件类型
        'stake' = 1,
        'unstake' = 2,
        'claim' = 3
    ),
    amount UInt64,                      -- 涉及的数量
    reward_amount UInt64,               -- 奖励数量（仅 claim 事件）
    timestamp DateTime64(3),            -- 事件时间
    block_height UInt64,                -- 区块高度
    slot UInt64,                        -- Solana slot
    signature String,                   -- 交易签名
    emission_rate UInt64,               -- 当时的排放率
    total_staked UInt64                 -- 当时的总质押量
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (user_address, timestamp, event_id);
```

---

## 5. 接口设计

### 5.1 智能合约指令 (Instructions)

#### 5.1.1 initialize
```rust
pub fn initialize(
    ctx: Context<Initialize>,
    emission_type: EmissionType,
    emission_rate: u64,
) -> Result<()>
```
**描述**: 初始化流动性池和质押系统

#### 5.1.2 deposit
```rust
pub fn deposit(
    ctx: Context<Deposit>,
    amount: u64,
) -> Result<()>
```
**描述**: 存入 wrappedUSDC，获得 LP Token

#### 5.1.3 withdraw
```rust
pub fn withdraw(
    ctx: Context<Withdraw>,
    lp_amount: u64,
) -> Result<()>
```
**描述**: 销毁 LP Token，赎回 wrappedUSDC

#### 5.1.4 stake
```rust
pub fn stake(
    ctx: Context<Stake>,
    amount: u64,
) -> Result<()>
```
**描述**: 质押 LP Token 开始挖矿

#### 5.1.5 unstake
```rust
pub fn unstake(
    ctx: Context<Unstake>,
    amount: u64,
) -> Result<()>
```
**描述**: 解除质押 LP Token

#### 5.1.6 claim
```rust
pub fn claim(
    ctx: Context<Claim>,
) -> Result<()>
```
**描述**: 领取累计的奖励

#### 5.1.7 update_reward_config
```rust
pub fn update_reward_config(
    ctx: Context<UpdateRewardConfig>,
    new_emission_rate: Option<u64>,
    new_emission_type: Option<EmissionType>,
) -> Result<()>
```
**描述**: 更新奖励配置（仅管理员）

### 5.2 客户端 SDK 接口

```typescript
class LiquidityStakingClient {
    // 初始化
    async initialize(
        emissionType: EmissionType,
        emissionRate: BN
    ): Promise<string>;
    
    // 存入
    async deposit(amount: BN): Promise<string>;
    
    // 提取
    async withdraw(lpAmount: BN): Promise<string>;
    
    // 质押
    async stake(amount: BN): Promise<string>;
    
    // 解除质押
    async unstake(amount: BN): Promise<string>;
    
    // 领取奖励
    async claim(): Promise<string>;
    
    // 查询用户持仓
    async getUserPosition(userAddress: PublicKey): Promise<UserPosition>;
    
    // 查询池状态
    async getPoolState(): Promise<PoolState>;
    
    // 计算待领取奖励
    async calculatePendingReward(userAddress: PublicKey): Promise<BN>;
}
```

---

## 6. 安全性设计

### 6.1 权限控制
- **管理员权限**: 仅管理员可初始化池子和更新奖励配置
- **用户权限**: 用户只能操作自己的仓位
- **PDA 验证**: 所有账户使用 PDA 派生，防止伪造

### 6.2 数值安全
- **溢出检查**: 使用 `checked_add`, `checked_mul` 等安全数学运算
- **精度处理**: 奖励计算使用 u128 防止精度丢失
- **最小金额限制**: 设置最小存入/质押金额防止粉尘攻击

### 6.3 重入保护
- **状态先更新**: 在转账前更新状态，防止重入攻击
- **单一责任**: 每个指令只完成一个核心操作

### 6.4 异常处理
- **余额检查**: 所有操作前检查余额充足
- **时间戳验证**: 防止时间回退攻击
- **紧急暂停**: 预留紧急暂停功能（可选）

---

## 7. 测试策略

### 7.1 单元测试
- 奖励计算逻辑测试
- PDA 派生正确性测试
- 数学运算边界测试

### 7.2 集成测试
- 完整存取流程测试
- 质押挖矿流程测试
- 多用户并发测试
- 奖励分配准确性测试

### 7.3 压力测试
- 大量用户同时操作
- 极端数值测试
- 长时间运行测试

### 7.4 安全测试
- 权限绕过测试
- 重入攻击测试
- 整数溢出测试

---

## 8. 部署方案

### 8.1 开发环境
```bash
# 启动本地测试网
solana-test-validator

# 部署合约
anchor deploy

# 初始化系统
npm run initialize
```

### 8.2 测试环境
- 使用 Solana Devnet
- 配置测试用的 wrappedUSDC Token
- 部署 ClickHouse 测试实例

### 8.3 生产环境（未来）
- 部署到 Solana Mainnet
- 配置真实的 wrappedUSDC
- 高可用 ClickHouse 集群
- 监控和告警系统

---

## 9. 开发计划

### 9.1 Phase 1: 基础框架（1-2周）
- [x] 项目初始化
- [ ] Anchor 项目脚手架
- [ ] wrappedUSDC Token 创建
- [ ] LP Token 程序集成
- [ ] 基础账户结构定义

### 9.2 Phase 2: 核心功能（2-3周）
- [ ] 流动性池实现（deposit/withdraw）
- [ ] 质押功能实现（stake/unstake）
- [ ] 固定速率奖励分配
- [ ] 按块动态奖励分配
- [ ] 单元测试编写

### 9.3 Phase 3: 数据层（1-2周）
- [ ] ClickHouse 表结构创建
- [ ] 事件监听器开发
- [ ] 数据采集服务
- [ ] 查询接口实现

### 9.4 Phase 4: 测试与优化（1-2周）
- [ ] 集成测试
- [ ] 安全审计
- [ ] 性能优化
- [ ] 文档完善

### 9.5 Phase 5: 部署与监控（1周）
- [ ] 测试网部署
- [ ] 监控系统搭建
- [ ] 使用文档编写
- [ ] 演示 Demo 准备

---

## 10. 风险与挑战

### 10.1 技术风险
- **Solana 网络拥堵**: 高峰期可能导致交易失败
- **奖励计算精度**: 需要仔细处理浮点运算
- **数据同步延迟**: ClickHouse 写入可能有延迟

### 10.2 安全风险
- **智能合约漏洞**: 需要严格的代码审查
- **价格操纵**: LP Token 比例计算需要防闪电贷攻击
- **私钥安全**: 管理员私钥保管至关重要

### 10.3 运营风险
- **奖励池耗尽**: 需要监控奖励余额
- **流动性不足**: 初期可能缺乏流动性
- **用户教育**: DeFi 操作有一定门槛

---

## 11. 后续扩展方向

### 11.1 功能扩展
- 多币种流动性池支持
- 流动性挖矿 Boost 机制
- NFT 加成系统
- 推荐奖励机制

### 11.2 性能优化
- 批量操作支持
- Gas 费优化
- 数据查询缓存

### 11.3 生态集成
- 与其他 DeFi 协议集成
- 跨链桥接支持
- 治理代币引入

---

## 12. 附录

### 12.1 参考资料
- [Solana 官方文档](https://docs.solana.com/)
- [Anchor 框架文档](https://www.anchor-lang.com/)
- [SPL Token 文档](https://spl.solana.com/token)
- [ClickHouse 文档](https://clickhouse.com/docs)

### 12.2 术语表
- **LP Token**: Liquidity Provider Token，流动性提供者代币
- **wrappedUSDC**: 桥接后的 USDC 稳定币
- **PDA**: Program Derived Address，程序派生地址
- **Emission Rate**: 排放速率，单位时间内产出的奖励数量
- **Reward Debt**: 奖励债务，用于计算用户实际可领取奖励的辅助值（Masterchef 算法）
- **Staking**: 质押，将代币锁定在合约中以赚取奖励
- **Farming**: 流动性挖矿，通过提供流动性赚取奖励的过程

### 12.3 完整操作流程示例

#### 示例：Alice 的完整 DeFi 之旅

**初始状态**：
- Alice 持有 1000 wrappedUSDC
- 池子配置：固定排放率 10 SOL/秒

**第 1 天：提供流动性**
```
操作: Alice 调用 deposit(1000 USDC)
结果: 
  - Alice 获得 1000 LP Token
  - 池子状态: 1000 USDC, 1000 LP
  - Alice 持有: 0 USDC, 1000 LP Token
```

**第 2 天：开始质押挖矿**
```
操作: Alice 调用 stake(1000 LP)
结果:
  - 1000 LP Token 被质押
  - 开始赚取 SOL 奖励
  - 总质押量: 1000 LP (Alice 占比 100%)
```

**第 3-10 天：持续挖矿（7天）**
```
经过时间: 7天 = 604,800 秒
奖励计算:
  user_reward = (1000/1000) × 10 × 604,800 = 6,048,000 SOL
```

**第 11 天：领取奖励（不解除质押）**
```
操作: Alice 调用 claim()
结果:
  - Alice 收到 6,048,000 SOL
  - 质押继续，LP Token 仍在质押中
  - 继续赚取新奖励
```

**第 20 天：部分解除质押**
```
操作: Alice 调用 unstake(500 LP)
结果:
  - 500 LP Token 返回给 Alice
  - 剩余 500 LP 继续质押
  - 待领取奖励继续累积
```

**第 30 天：赎回流动性**
```
操作1: Alice 调用 claim() 领取剩余奖励
操作2: Alice 调用 unstake(500 LP) 解除剩余质押
操作3: Alice 调用 withdraw(1000 LP) 赎回本金
结果:
  - Alice 获得 1000 USDC（本金）
  - Alice 获得所有累积的 SOL 奖励
  - 退出完成
```

**收益总结**：
- 本金：1000 USDC（已赎回）
- 挖矿奖励：大量 SOL（具体取决于质押时长和占比）
- 风险：合约风险、无常损失（本例为单币池，无此风险）

### 12.4 联系方式
- 项目负责人: [待定]
- 技术支持: [待定]
- 文档版本: v1.0
- 最后更新: 2025-10-31

---

**文档状态**: 待审核
**审核人**: [待定]
**审核日期**: [待定]
